#!/usr/bin/env node

const encodings = {

  "pson"(){
    const PSON = require('pson');
    const pson = new PSON.ProgressivePair();
    require('get-stdin')
    .buffer()
    .then(b => {
      const data = JSON.parse(b);
      let bOut = pson.toBuffer(data); //First seed dict
      bOut = pson.toBuffer(data);     //Then again seeded
      process.stdout.write(bOut);
    });
  },

  "bson"(){
    const BSON = require('bson');
    const bson = new BSON();
    require('get-stdin')
    .buffer()
    .then(b => {
      const data = JSON.parse(b);
      let out = bson.serialize(data);
      process.stdout.write(out);
    });
  },

  "cbor"(){
    const cbor = require('borc');

    require('get-stdin')
    .buffer()
    .then(b => {
      const data = JSON.parse(b);
      const out = cbor.encode(data);
      process.stdout.write(out);
    });
  },

  "msgpack"(){
    var msgpack = require("msgpack-lite");

    require('get-stdin')
    .buffer()
    .then(b => {
      const data = JSON.parse(b);
      const out = msgpack.encode(data);
      process.stdout.write(out);
    });
  },

  "avro"(schema){
    const avro = require('avsc');
    const { setNulls } = require('./src/utils');

    let type;

    if(schema === "6NF"){
      type = avro.Type.forSchema(require('./src/Naringsvarde.6NF.avro-schema.json'));
    } else
    if (schema === "5NF"){
      type = avro.Type.forSchema(require('./src/Naringsvarde.5NF.avro-schema.json'));
    }

    require('get-stdin')
    .buffer()
    .then(b => {
      const data = JSON.parse(b);

      if(schema === "6NF"){
        for(const key of Object.keys(data.Livsmedel.Naringsvarde)){
          setNulls(data.Livsmedel.Naringsvarde[key].Varde,NaN);
        }
      }

      type.isValid(data,{
        noUndeclaredFields: true,
        errorHook(path, any, type){
          const util = require('util');
          throw new Error(util.format('invalid %s: %j', path.join(), any));
        }
      });

      const out = type.toBuffer(data);
      process.stdout.write(out);
    });
  },

};

process.on('unhandledRejection', error => {
  throw error;
});


const encoding = encodings[process.argv[2]];
const schema   = process.argv[3];
if (typeof encoding === 'function') {
  encoding(schema);
} else {
  throw new Error("Unsupported encoding: " + process.argv[2]);
}
